<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eliza City</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&family=Nunito:ital@0;1&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a2e; font-family: 'Nunito', sans-serif; }
    canvas { display: block; }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ffd1dc;
      font-family: 'Quicksand', sans-serif;
      font-size: 24px;
      text-align: center;
      z-index: 100;
    }
    #loading .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #ff69b4;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-family: 'Nunito', sans-serif;
      font-size: 14px;
      background: linear-gradient(135deg, rgba(255, 105, 180, 0.8), rgba(148, 0, 211, 0.8));
      padding: 12px 18px;
      border-radius: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
    }

    /* Cute Anime UI Theme */
    #ui-container {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 320px;
      max-height: calc(100vh - 20px);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
    }

    .panel {
      background: linear-gradient(180deg, rgba(255, 182, 193, 0.95), rgba(255, 218, 233, 0.9));
      border: 3px solid #ff69b4;
      border-radius: 20px;
      color: #4a154b;
      overflow: hidden;
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.5);
    }

    .panel-header {
      background: linear-gradient(180deg, #ff69b4, #ff1493);
      padding: 10px 14px;
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 14px;
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .panel-header .status {
      font-family: 'Nunito', sans-serif;
      font-size: 11px;
      padding: 3px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.5);
    }

    .panel-header .status.connected {
      background: rgba(144, 238, 144, 0.8);
      color: #006400;
    }

    .panel-header .status.disconnected {
      background: rgba(255, 99, 71, 0.8);
      color: #8b0000;
    }

    .panel-content {
      padding: 10px;
      overflow-y: auto;
      max-height: 200px;
    }

    #agents-panel { flex: 0 0 auto; }
    #agents-panel .panel-content {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .agent-card {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.7), rgba(255, 240, 245, 0.8));
      border: 2px solid #ffb6c1;
      border-radius: 15px;
      padding: 8px 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.2s;
    }

    .agent-card:hover {
      transform: scale(1.02);
      border-color: #ff69b4;
      box-shadow: 0 4px 12px rgba(255, 105, 180, 0.3);
    }

    .agent-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff69b4, #da70d6);
      border: 2px solid white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 14px;
      color: white;
      flex-shrink: 0;
      box-shadow: 0 2px 8px rgba(255, 105, 180, 0.4);
    }

    .agent-info { flex: 1; min-width: 0; }

    .agent-name {
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 13px;
      color: #4a154b;
    }

    .agent-role {
      font-size: 11px;
      color: #9b59b6;
      text-transform: capitalize;
    }

    .agent-status {
      font-size: 10px;
      padding: 3px 10px;
      border-radius: 10px;
      text-transform: capitalize;
      font-weight: 600;
    }

    .agent-status.idle { background: #e8daef; color: #8e44ad; }
    .agent-status.working { background: #d5f5e3; color: #27ae60; }
    .agent-status.traveling { background: #fdebd0; color: #e67e22; }
    .agent-status.chatting { background: #fadbd8; color: #e74c3c; }

    #tasks-panel { flex: 0 0 auto; }

    .task-item {
      background: rgba(255, 255, 255, 0.6);
      border: 2px solid #dda0dd;
      border-left: 4px solid #ff69b4;
      border-radius: 10px;
      padding: 8px 10px;
      margin-bottom: 6px;
    }

    .task-item.completed { border-left-color: #90ee90; opacity: 0.7; }
    .task-item.in_progress { border-left-color: #ffa500; }

    .task-title {
      font-size: 12px;
      font-weight: 600;
      color: #4a154b;
    }

    .task-meta {
      font-size: 10px;
      color: #9b59b6;
      margin-top: 3px;
    }

    #messages-panel { flex: 1; min-height: 150px; }
    #messages-panel .panel-content {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .message-item {
      background: rgba(255, 255, 255, 0.5);
      border: 1px solid #ffb6c1;
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 11px;
    }

    .message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
    }

    .message-agent {
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 11px;
      color: #ff69b4;
    }

    .message-time {
      font-size: 9px;
      color: #9b59b6;
    }

    .message-content {
      color: #4a154b;
      line-height: 1.4;
    }

    .message-type {
      display: inline-block;
      font-size: 8px;
      padding: 2px 6px;
      border-radius: 8px;
      margin-right: 5px;
      text-transform: uppercase;
      font-weight: 700;
    }

    .message-type.thought { background: #e8daef; color: #8e44ad; }
    .message-type.chat { background: #fadbd8; color: #e74c3c; }
    .message-type.status { background: #d5f5e3; color: #27ae60; }
    .message-type.announcement { background: #fdebd0; color: #e67e22; }

    #task-input-container {
      padding: 14px;
      background: linear-gradient(180deg, rgba(255, 182, 193, 0.95), rgba(255, 218, 233, 0.9));
      border: 3px solid #ff69b4;
      border-radius: 20px;
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.3);
    }

    .input-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .input-header label {
      font-family: 'Quicksand', sans-serif;
      font-size: 13px;
      font-weight: 700;
      color: #ff1493;
    }

    .input-header .char-count {
      font-size: 10px;
      color: #9b59b6;
    }

    #task-input {
      width: 100%;
      background: white;
      border: 2px solid #ffb6c1;
      border-radius: 12px;
      padding: 12px;
      color: #4a154b;
      font-family: 'Nunito', sans-serif;
      font-size: 14px;
      resize: none;
      line-height: 1.5;
      transition: all 0.2s ease;
    }

    #task-input:focus {
      outline: none;
      border-color: #ff69b4;
      box-shadow: 0 0 0 3px rgba(255, 105, 180, 0.2);
    }

    #task-input::placeholder {
      color: #dda0dd;
    }

    .button-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    #submit-task {
      flex: 1;
      padding: 10px 16px;
      background: linear-gradient(180deg, #ff69b4, #ff1493);
      border: 2px solid white;
      border-radius: 12px;
      color: white;
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(255, 105, 180, 0.4);
    }

    #submit-task:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(255, 105, 180, 0.5);
    }

    #submit-task:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: #ddd;
    }

    #submit-task.success {
      background: linear-gradient(180deg, #90ee90, #32cd32);
    }

    #submit-task.error {
      background: linear-gradient(180deg, #ff6b6b, #ee5a5a);
    }

    .priority-select {
      background: white;
      border: 2px solid #ffb6c1;
      border-radius: 12px;
      padding: 10px 12px;
      color: #4a154b;
      font-family: 'Nunito', sans-serif;
      font-size: 13px;
      cursor: pointer;
    }

    .server-status {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 8px;
      font-size: 10px;
      color: #9b59b6;
    }

    .server-status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ff6b6b;
    }

    .server-status .dot.online {
      background: #90ee90;
      box-shadow: 0 0 8px #90ee90;
    }

    .panel-content::-webkit-scrollbar { width: 8px; }
    .panel-content::-webkit-scrollbar-track { background: #fce4ec; border-radius: 4px; }
    .panel-content::-webkit-scrollbar-thumb { background: #ff69b4; border-radius: 4px; }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div>Loading Eliza City...</div>
  </div>
  <div id="info">
    Mouse: Rotate | Scroll: Zoom | Right-click: Pan
  </div>

  <div id="ui-container">
    <div id="agents-panel" class="panel">
      <div class="panel-header">
        <span>Agents</span>
        <span id="ws-status" class="status disconnected">Offline</span>
      </div>
      <div class="panel-content" id="agents-list">
        <div style="color: #9b59b6; font-size: 12px; text-align: center; padding: 20px;">
          Connecting to server...
        </div>
      </div>
    </div>

    <div id="tasks-panel" class="panel">
      <div class="panel-header">
        <span>Active Tasks</span>
        <span id="task-count" style="font-size: 11px; color: rgba(255,255,255,0.8);">0</span>
      </div>
      <div class="panel-content" id="tasks-list">
        <div style="color: #9b59b6; font-size: 12px; text-align: center; padding: 20px;">
          No active tasks
        </div>
      </div>
    </div>

    <div id="messages-panel" class="panel">
      <div class="panel-header">
        <span>Activity Feed</span>
      </div>
      <div class="panel-content" id="messages-list">
        <div style="color: #9b59b6; font-size: 12px; text-align: center; padding: 20px;">
          Waiting for activity...
        </div>
      </div>
    </div>

    <div id="task-input-container">
      <div class="input-header">
        <label>Assign a Task</label>
        <span class="char-count"><span id="char-count">0</span>/500</span>
      </div>
      <textarea id="task-input" rows="3" placeholder="What should the girls work on?" maxlength="500"></textarea>
      <div class="button-row">
        <select class="priority-select" id="priority-select">
          <option value="3">Urgent!</option>
          <option value="5" selected>Normal</option>
          <option value="7">Whenever~</option>
        </select>
        <button id="submit-task" disabled>
          <span id="submit-text">Send Task</span>
        </button>
      </div>
      <div class="server-status">
        <span class="dot" id="server-dot"></span>
        <span id="server-status-text">Checking server...</span>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene setup - Anime City vibes
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.008);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(80, 60, 80);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 10;
    controls.maxDistance = 250;
    controls.target.set(0, 0, 0);

    // Soft anime-style lighting
    const ambientLight = new THREE.AmbientLight(0xffeef5, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
    sunLight.position.set(50, 80, 30);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 400;
    sunLight.shadow.camera.left = -150;
    sunLight.shadow.camera.right = 150;
    sunLight.shadow.camera.top = 150;
    sunLight.shadow.camera.bottom = -150;
    scene.add(sunLight);

    // Pink rim light for anime feel
    const rimLight = new THREE.DirectionalLight(0xffb6c1, 0.4);
    rimLight.position.set(-30, 20, -30);
    scene.add(rimLight);

    // Ground - City streets
    const groundGeo = new THREE.PlaneGeometry(400, 400);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const clock = new THREE.Clock();
    const characters = [];

    // City waypoints
    const waypoints = {
      center: { x: 0, z: 0 },
      north: { x: 0, z: -40 },
      south: { x: 0, z: 40 },
      east: { x: 40, z: 0 },
      west: { x: -40, z: 0 },
      ne: { x: 30, z: -30 },
      nw: { x: -30, z: -30 },
      se: { x: 30, z: 30 },
      sw: { x: -30, z: 30 },
      cafe: { x: -20, z: -15 },
      shop: { x: 20, z: -15 },
      park: { x: 0, z: 25 },
      station: { x: -35, z: 10 },
      school: { x: 35, z: -25 },
    };

    const connections = {
      center: ['north', 'south', 'east', 'west', 'cafe', 'shop', 'park'],
      north: ['center', 'ne', 'nw'],
      south: ['center', 'se', 'sw', 'park'],
      east: ['center', 'ne', 'se', 'shop', 'school'],
      west: ['center', 'nw', 'sw', 'cafe', 'station'],
      ne: ['north', 'east', 'school'],
      nw: ['north', 'west', 'cafe'],
      se: ['south', 'east'],
      sw: ['south', 'west', 'station'],
      cafe: ['center', 'west', 'nw'],
      shop: ['center', 'east'],
      park: ['center', 'south'],
      station: ['west', 'sw'],
      school: ['east', 'ne'],
    };

    // Anime girl character colors
    const animeGirls = [
      { name: 'Sakura', hair: 0xffb7c5, dress: 0xff69b4, skin: 0xffe4c4 },
      { name: 'Yuki', hair: 0xe6e6fa, dress: 0x9370db, skin: 0xffefd5 },
      { name: 'Hana', hair: 0xffd700, dress: 0x32cd32, skin: 0xffe4c4 },
      { name: 'Miku', hair: 0x00ced1, dress: 0x4169e1, skin: 0xffefd5 },
      { name: 'Rei', hair: 0x1e90ff, dress: 0xffffff, skin: 0xffe4c4 },
      { name: 'Akari', hair: 0xff4500, dress: 0xffa500, skin: 0xffefd5 },
      { name: 'Luna', hair: 0x9932cc, dress: 0x000080, skin: 0xffe4c4 },
      { name: 'Sora', hair: 0x87ceeb, dress: 0xffc0cb, skin: 0xffefd5 },
    ];

    // Create anime girl character
    function createAnimeGirl(config) {
      const group = new THREE.Group();

      // Body/Dress
      const bodyGeo = new THREE.CylinderGeometry(0.3, 0.5, 1.2, 8);
      const bodyMat = new THREE.MeshStandardMaterial({ color: config.dress });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.8;
      body.castShadow = true;
      group.add(body);

      // Head
      const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
      const headMat = new THREE.MeshStandardMaterial({ color: config.skin });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.7;
      head.castShadow = true;
      group.add(head);

      // Hair (big anime hair!)
      const hairGeo = new THREE.SphereGeometry(0.42, 16, 16);
      const hairMat = new THREE.MeshStandardMaterial({ color: config.hair });
      const hair = new THREE.Mesh(hairGeo, hairMat);
      hair.position.y = 1.75;
      hair.position.z = -0.05;
      hair.scale.set(1, 1.1, 1);
      hair.castShadow = true;
      group.add(hair);

      // Bangs
      const bangsGeo = new THREE.BoxGeometry(0.5, 0.15, 0.2);
      const bangs = new THREE.Mesh(bangsGeo, hairMat);
      bangs.position.set(0, 1.9, 0.25);
      group.add(bangs);

      // Side hair
      const sideHairGeo = new THREE.CylinderGeometry(0.08, 0.04, 0.6, 8);
      const leftHair = new THREE.Mesh(sideHairGeo, hairMat);
      leftHair.position.set(-0.35, 1.5, 0.1);
      leftHair.rotation.z = 0.2;
      group.add(leftHair);
      const rightHair = new THREE.Mesh(sideHairGeo, hairMat);
      rightHair.position.set(0.35, 1.5, 0.1);
      rightHair.rotation.z = -0.2;
      group.add(rightHair);

      // Eyes (big anime eyes!)
      const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.12, 1.72, 0.28);
      leftEye.scale.set(1, 1.3, 0.5);
      group.add(leftEye);
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      rightEye.position.set(0.12, 1.72, 0.28);
      rightEye.scale.set(1, 1.3, 0.5);
      group.add(rightEye);

      // Eye highlights
      const highlightGeo = new THREE.SphereGeometry(0.03, 8, 8);
      const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const leftHighlight = new THREE.Mesh(highlightGeo, highlightMat);
      leftHighlight.position.set(-0.1, 1.74, 0.32);
      group.add(leftHighlight);
      const rightHighlight = new THREE.Mesh(highlightGeo, highlightMat);
      rightHighlight.position.set(0.14, 1.74, 0.32);
      group.add(rightHighlight);

      // Legs
      const legGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.5, 8);
      const legMat = new THREE.MeshStandardMaterial({ color: config.skin });
      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-0.15, 0.25, 0);
      leftLeg.castShadow = true;
      group.add(leftLeg);
      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(0.15, 0.25, 0);
      rightLeg.castShadow = true;
      group.add(rightLeg);

      group.scale.set(1.5, 1.5, 1.5);
      return group;
    }

    // Create city building
    function createBuilding(width, height, depth, color, windows = true) {
      const group = new THREE.Group();

      const buildingGeo = new THREE.BoxGeometry(width, height, depth);
      const buildingMat = new THREE.MeshStandardMaterial({ color });
      const building = new THREE.Mesh(buildingGeo, buildingMat);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);

      if (windows) {
        const windowMat = new THREE.MeshBasicMaterial({ color: 0x87ceeb });
        const windowSize = 0.8;
        const rows = Math.floor(height / 3);
        const cols = Math.floor(width / 3);

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const windowGeo = new THREE.PlaneGeometry(windowSize, windowSize * 1.2);
            const windowMesh = new THREE.Mesh(windowGeo, windowMat);
            windowMesh.position.set(
              -width / 2 + 1.5 + col * 3,
              2 + row * 3,
              depth / 2 + 0.01
            );
            group.add(windowMesh);

            const backWindow = windowMesh.clone();
            backWindow.position.z = -depth / 2 - 0.01;
            backWindow.rotation.y = Math.PI;
            group.add(backWindow);
          }
        }
      }

      return group;
    }

    // Character class
    class AnimeCharacter {
      constructor(model, startWaypoint, config) {
        this.model = model;
        this.config = config;
        this.currentWaypoint = startWaypoint;
        this.targetWaypoint = null;
        this.lastWaypoint = null;

        this.maxSpeed = 2 + Math.random() * 1;
        this.currentSpeed = 0;
        this.turnSpeed = 4;

        this.state = 'idle';
        this.stateTime = 0;
        this.idleDuration = 2 + Math.random() * 3;
        this.bouncePhase = Math.random() * Math.PI * 2;
      }

      lerpAngle(from, to, t) {
        let diff = to - from;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return from + diff * Math.min(t, 1);
      }

      pickNextWaypoint() {
        const possibleNext = connections[this.currentWaypoint];
        if (!possibleNext) return null;
        let choices = possibleNext.filter(w => w !== this.lastWaypoint);
        if (choices.length === 0) choices = possibleNext;
        return choices[Math.floor(Math.random() * choices.length)];
      }

      update(delta) {
        this.stateTime += delta;
        this.bouncePhase += delta * 8;

        switch (this.state) {
          case 'idle':
            // Cute idle animation
            this.model.position.y = Math.sin(this.bouncePhase * 0.5) * 0.05;
            this.model.rotation.y += Math.sin(this.stateTime * 2) * 0.002;

            if (this.stateTime > this.idleDuration) {
              this.targetWaypoint = this.pickNextWaypoint();
              if (this.targetWaypoint) {
                this.state = 'walking';
                this.stateTime = 0;
              }
            }
            break;

          case 'walking':
            const target = waypoints[this.targetWaypoint];
            const dx = target.x - this.model.position.x;
            const dz = target.z - this.model.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            const targetAngle = Math.atan2(dx, dz);

            this.model.rotation.y = this.lerpAngle(this.model.rotation.y, targetAngle, delta * this.turnSpeed);
            this.currentSpeed = Math.min(this.currentSpeed + 4 * delta, this.maxSpeed);

            // Cute bouncy walk
            this.model.position.y = Math.abs(Math.sin(this.bouncePhase)) * 0.15;

            if (dist > 0.5) {
              this.model.position.x += (dx / dist) * this.currentSpeed * delta;
              this.model.position.z += (dz / dist) * this.currentSpeed * delta;
            } else {
              this.lastWaypoint = this.currentWaypoint;
              this.currentWaypoint = this.targetWaypoint;
              this.targetWaypoint = null;
              this.currentSpeed = 0;
              this.state = 'idle';
              this.stateTime = 0;
              this.idleDuration = 1.5 + Math.random() * 3;
              this.model.position.y = 0;
            }
            break;
        }
      }
    }

    // Build the city
    function buildCity() {
      // Streets (darker pavement)
      const streetMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const mainStreetNS = new THREE.Mesh(new THREE.PlaneGeometry(12, 200), streetMat);
      mainStreetNS.rotation.x = -Math.PI / 2;
      mainStreetNS.position.y = 0.01;
      scene.add(mainStreetNS);

      const mainStreetEW = new THREE.Mesh(new THREE.PlaneGeometry(200, 12), streetMat);
      mainStreetEW.rotation.x = -Math.PI / 2;
      mainStreetEW.position.y = 0.01;
      scene.add(mainStreetEW);

      // Crosswalk stripes
      const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      for (let i = -4; i <= 4; i++) {
        const stripe = new THREE.Mesh(new THREE.PlaneGeometry(1, 5), stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(i * 1.5, 0.02, 0);
        scene.add(stripe);
      }

      // Buildings - City blocks
      const buildingColors = [0xf5deb3, 0xdda0dd, 0xb0c4de, 0xf0e68c, 0xe6e6fa, 0xffc0cb];

      // Northwest block - Offices
      const b1 = createBuilding(15, 30, 15, 0xb0c4de);
      b1.position.set(-35, 0, -35);
      scene.add(b1);

      const b2 = createBuilding(12, 20, 12, 0xf5deb3);
      b2.position.set(-20, 0, -40);
      scene.add(b2);

      // Northeast block - Shopping
      const b3 = createBuilding(18, 12, 15, 0xffc0cb);
      b3.position.set(30, 0, -35);
      scene.add(b3);

      const b4 = createBuilding(10, 25, 10, 0xe6e6fa);
      b4.position.set(45, 0, -40);
      scene.add(b4);

      // Southwest block - Residential
      const b5 = createBuilding(12, 15, 12, 0xdda0dd);
      b5.position.set(-35, 0, 35);
      scene.add(b5);

      const b6 = createBuilding(10, 18, 10, 0xf0e68c);
      b6.position.set(-45, 0, 25);
      scene.add(b6);

      // Southeast block - More shops
      const b7 = createBuilding(14, 10, 14, 0xffc0cb);
      b7.position.set(35, 0, 35);
      scene.add(b7);

      const b8 = createBuilding(16, 22, 12, 0xb0c4de);
      b8.position.set(45, 0, 20);
      scene.add(b8);

      // Cafe (cute small building)
      const cafe = createBuilding(8, 6, 8, 0xff69b4, false);
      cafe.position.set(-22, 0, -15);
      scene.add(cafe);

      // School building
      const school = createBuilding(20, 12, 15, 0xfffacd);
      school.position.set(40, 0, -25);
      scene.add(school);

      // Train station
      const station = createBuilding(15, 8, 25, 0x778899);
      station.position.set(-40, 0, 10);
      scene.add(station);

      // Park with trees
      const parkGround = new THREE.Mesh(
        new THREE.CircleGeometry(15, 32),
        new THREE.MeshStandardMaterial({ color: 0x90ee90 })
      );
      parkGround.rotation.x = -Math.PI / 2;
      parkGround.position.set(0, 0.02, 28);
      scene.add(parkGround);

      // Cherry blossom trees in park
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const tree = createTree();
        tree.position.set(
          Math.cos(angle) * 10,
          0,
          28 + Math.sin(angle) * 10
        );
        scene.add(tree);
      }

      // Street lamps
      for (let x = -60; x <= 60; x += 20) {
        const lamp = createStreetLamp();
        lamp.position.set(x, 0, 8);
        scene.add(lamp);
        const lamp2 = lamp.clone();
        lamp2.position.set(x, 0, -8);
        scene.add(lamp2);
      }

      // Add anime girl characters
      const startPoints = ['center', 'cafe', 'shop', 'park', 'station', 'school', 'ne', 'sw'];
      animeGirls.forEach((config, i) => {
        const model = createAnimeGirl(config);
        const start = startPoints[i % startPoints.length];
        const pos = waypoints[start];
        model.position.set(pos.x, 0, pos.z);
        model.rotation.y = Math.random() * Math.PI * 2;
        scene.add(model);
        characters.push(new AnimeCharacter(model, start, config));
      });

      document.getElementById('loading').style.display = 'none';
    }

    function createTree() {
      const group = new THREE.Group();

      // Trunk
      const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 1.5;
      trunk.castShadow = true;
      group.add(trunk);

      // Cherry blossom foliage (pink!)
      const foliageGeo = new THREE.SphereGeometry(2.5, 16, 16);
      const foliageMat = new THREE.MeshStandardMaterial({ color: 0xffb7c5 });
      const foliage = new THREE.Mesh(foliageGeo, foliageMat);
      foliage.position.y = 4.5;
      foliage.castShadow = true;
      group.add(foliage);

      return group;
    }

    function createStreetLamp() {
      const group = new THREE.Group();

      const poleMat = new THREE.MeshStandardMaterial({ color: 0x2f2f2f });
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5, 8), poleMat);
      pole.position.y = 2.5;
      group.add(pole);

      const lampMat = new THREE.MeshBasicMaterial({ color: 0xfffacd });
      const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), lampMat);
      lamp.position.y = 5.2;
      group.add(lamp);

      return group;
    }

    buildCity();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      for (const char of characters) char.update(delta);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // WebSocket & UI code
    const wsStatus = document.getElementById('ws-status');
    const agentsList = document.getElementById('agents-list');
    const tasksList = document.getElementById('tasks-list');
    const taskCount = document.getElementById('task-count');
    const messagesList = document.getElementById('messages-list');
    const taskInput = document.getElementById('task-input');
    const submitTask = document.getElementById('submit-task');
    const charCount = document.getElementById('char-count');
    const prioritySelect = document.getElementById('priority-select');
    const submitText = document.getElementById('submit-text');
    const serverDot = document.getElementById('server-dot');
    const serverStatusText = document.getElementById('server-status-text');

    let ws = null;
    let serverOnline = false;

    taskInput.addEventListener('input', () => {
      charCount.textContent = taskInput.value.length;
    });

    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

      ws.onopen = () => {
        wsStatus.textContent = 'Online';
        wsStatus.className = 'status connected';
        submitTask.disabled = false;
      };

      ws.onclose = () => {
        wsStatus.textContent = 'Offline';
        wsStatus.className = 'status disconnected';
        submitTask.disabled = true;
        setTimeout(connectWebSocket, 3000);
      };

      ws.onerror = () => {};

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          if (msg.type === 'state_update') {
            updateUI(msg.data);
          }
        } catch (e) {}
      };
    }

    function updateUI(data) {
      if (data.agents?.length > 0) {
        agentsList.innerHTML = data.agents.map(a => `
          <div class="agent-card">
            <div class="agent-avatar">${a.name.charAt(0)}</div>
            <div class="agent-info">
              <div class="agent-name">${a.name}</div>
              <div class="agent-role">${a.type}</div>
            </div>
            <div class="agent-status ${a.status}">${a.status}</div>
          </div>
        `).join('');
      }

      const active = (data.tasks || []).filter(t => t.status !== 'completed').slice(0, 5);
      taskCount.textContent = active.length;
      if (active.length > 0) {
        tasksList.innerHTML = active.map(t => `
          <div class="task-item ${t.status}">
            <div class="task-title">${t.title}</div>
            <div class="task-meta">Priority: ${t.priority}</div>
          </div>
        `).join('');
      }

      if (data.messages?.length > 0) {
        messagesList.innerHTML = data.messages.slice(0, 10).map(m => `
          <div class="message-item">
            <div class="message-header">
              <span class="message-agent">${m.agent_name || 'Agent'}</span>
            </div>
            <div class="message-content">
              <span class="message-type ${m.type}">${m.type}</span>
              ${m.content}
            </div>
          </div>
        `).join('');
      }
    }

    async function checkServerHealth() {
      try {
        const res = await fetch('/api/health');
        if (res.ok) {
          const data = await res.json();
          serverOnline = true;
          serverDot.classList.add('online');
          serverStatusText.textContent = data.dbAvailable ? 'Server online - agents ready!' : 'Server online';
          submitTask.disabled = !data.dbAvailable;
        }
      } catch {
        serverOnline = false;
        serverDot.classList.remove('online');
        serverStatusText.textContent = 'Server offline';
        submitTask.disabled = true;
      }
    }

    checkServerHealth();
    setInterval(checkServerHealth, 10000);

    submitTask.addEventListener('click', async () => {
      const title = taskInput.value.trim();
      if (!title || !serverOnline) return;

      submitTask.disabled = true;
      submitText.textContent = 'Sending...';

      try {
        const res = await fetch('/api/tasks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, priority: parseInt(prioritySelect.value) })
        });
        if (res.ok) {
          taskInput.value = '';
          charCount.textContent = '0';
          submitTask.classList.add('success');
          submitText.textContent = 'Sent!';
          setTimeout(() => {
            submitTask.classList.remove('success');
            submitText.textContent = 'Send Task';
            submitTask.disabled = false;
          }, 2000);
        }
      } catch {
        submitTask.classList.add('error');
        submitText.textContent = 'Failed';
        setTimeout(() => {
          submitTask.classList.remove('error');
          submitText.textContent = 'Send Task';
          submitTask.disabled = false;
        }, 2000);
      }
    });

    taskInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey && !submitTask.disabled) {
        e.preventDefault();
        submitTask.click();
      }
    });

    connectWebSocket();
  </script>
</body>
</html>
