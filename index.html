<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eliza Town</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a2e; }
    canvas { display: block; }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
      text-align: center;
      z-index: 100;
    }
    #loading .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #333;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 10px 15px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div>Loading Eliza Town...</div>
  </div>
  <div id="info">
    Mouse: Rotate | Scroll: Zoom | Right-click drag: Pan
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x7EC8E3);
    scene.fog = new THREE.FogExp2(0x7EC8E3, 0.012);

    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 22, 30);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 5;
    controls.maxDistance = 80;
    controls.target.set(0, 0, 0);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.5);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.5);
    sunLight.position.set(30, 40, 20);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 150;
    sunLight.shadow.camera.left = -50;
    sunLight.shadow.camera.right = 50;
    sunLight.shadow.camera.top = 50;
    sunLight.shadow.camera.bottom = -50;
    sunLight.shadow.bias = -0.0001;
    scene.add(sunLight);

    const fillLight = new THREE.DirectionalLight(0x8ecae6, 0.3);
    fillLight.position.set(-20, 10, -20);
    scene.add(fillLight);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4a7c4e, roughness: 0.9 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.05;
    ground.receiveShadow = true;
    scene.add(ground);

    // Loaders & State
    const gltfLoader = new GLTFLoader();
    const clock = new THREE.Clock();
    let loadedCount = 0;
    let totalToLoad = 0;
    const characters = [];
    const animationClips = {};

    function updateLoading() {
      loadedCount++;
      if (loadedCount >= totalToLoad) {
        document.getElementById('loading').style.display = 'none';
      }
    }

    // ==================== ROAD NETWORK ====================
    // Define waypoints for roads - characters will walk between these
    const waypoints = {
      // Main street (north-south)
      northGate: { x: 0, z: -9 },
      northPlaza: { x: 0, z: -5 },
      center: { x: 0, z: 0 },
      southPlaza: { x: 0, z: 5 },
      southGate: { x: 0, z: 9 },

      // Cross street (east-west)
      westGate: { x: -9, z: 0 },
      westPlaza: { x: -5, z: 0 },
      eastPlaza: { x: 5, z: 0 },
      eastGate: { x: 9, z: 0 },

      // Tavern district (northwest)
      tavernFront: { x: -5, z: -4 },
      tavernBack: { x: -7, z: -6 },

      // Market district (northeast)
      marketFront: { x: 5, z: -4 },
      marketBack: { x: 7, z: -6 },

      // Residential west (southwest)
      houseWest1: { x: -6, z: 4 },
      houseWest2: { x: -7, z: 6 },

      // Residential east (southeast)
      houseEast1: { x: 6, z: 4 },
      houseEast2: { x: 7, z: 6 },

      // Side streets
      nwCorner: { x: -5, z: -5 },
      neCorner: { x: 5, z: -5 },
      swCorner: { x: -5, z: 5 },
      seCorner: { x: 5, z: 5 },
    };

    // Define connected routes (which waypoints connect to which)
    const connections = {
      northGate: ['northPlaza'],
      northPlaza: ['northGate', 'center', 'nwCorner', 'neCorner'],
      center: ['northPlaza', 'southPlaza', 'westPlaza', 'eastPlaza'],
      southPlaza: ['center', 'southGate', 'swCorner', 'seCorner'],
      southGate: ['southPlaza'],

      westGate: ['westPlaza'],
      westPlaza: ['westGate', 'center', 'nwCorner', 'swCorner'],
      eastPlaza: ['center', 'eastGate', 'neCorner', 'seCorner'],
      eastGate: ['eastPlaza'],

      nwCorner: ['northPlaza', 'westPlaza', 'tavernFront'],
      neCorner: ['northPlaza', 'eastPlaza', 'marketFront'],
      swCorner: ['southPlaza', 'westPlaza', 'houseWest1'],
      seCorner: ['southPlaza', 'eastPlaza', 'houseEast1'],

      tavernFront: ['nwCorner', 'tavernBack'],
      tavernBack: ['tavernFront'],
      marketFront: ['neCorner', 'marketBack'],
      marketBack: ['marketFront'],

      houseWest1: ['swCorner', 'houseWest2'],
      houseWest2: ['houseWest1'],
      houseEast1: ['seCorner', 'houseEast2'],
      houseEast2: ['houseEast1'],
    };

    // ==================== ANIMATIONS ====================
    async function loadAnimations() {
      return new Promise((resolve) => {
        let loaded = 0;
        const needed = 4;

        gltfLoader.load('assets/animations/rig_medium/General.glb', (gltf) => {
          animationClips.mediumGeneral = gltf.animations;
          if (++loaded === needed) resolve();
        });
        gltfLoader.load('assets/animations/rig_medium/MovementBasic.glb', (gltf) => {
          animationClips.mediumMovement = gltf.animations;
          if (++loaded === needed) resolve();
        });
        gltfLoader.load('assets/animations/rig_large/General.glb', (gltf) => {
          animationClips.largeGeneral = gltf.animations;
          if (++loaded === needed) resolve();
        });
        gltfLoader.load('assets/animations/rig_large/MovementBasic.glb', (gltf) => {
          animationClips.largeMovement = gltf.animations;
          if (++loaded === needed) resolve();
        });
      });
    }

    // ==================== CHARACTER CLASS ====================
    class Character {
      constructor(model, rig, startWaypoint) {
        this.model = model;
        this.rig = rig;
        this.mixer = new THREE.AnimationMixer(model);

        // Pathfinding
        this.currentWaypoint = startWaypoint;
        this.targetWaypoint = null;
        this.path = [];

        // Movement
        this.maxSpeed = 1.5 + Math.random() * 0.8;
        this.currentSpeed = 0;
        this.acceleration = 2.5;
        this.deceleration = 3.5;
        this.turnSpeed = 5.0;

        // State
        this.state = 'idle';
        this.stateTime = 0;
        this.idleDuration = 2 + Math.random() * 4;
        this.waitTime = 0;

        // Setup animations
        const generalClips = rig === 'large' ? animationClips.largeGeneral : animationClips.mediumGeneral;
        const movementClips = rig === 'large' ? animationClips.largeMovement : animationClips.mediumMovement;

        if (generalClips?.length > 0) {
          const idleOptions = generalClips.filter(c => c.name.includes('Idle'));
          const idleClip = idleOptions[Math.floor(Math.random() * idleOptions.length)] || generalClips[0];
          this.idleAction = this.mixer.clipAction(idleClip);
          this.idleAction.setEffectiveTimeScale(0.8 + Math.random() * 0.4);
          this.idleAction.play();
        }

        if (movementClips?.length > 0) {
          const walkOptions = movementClips.filter(c => c.name.includes('Walking'));
          const walkClip = walkOptions[Math.floor(Math.random() * walkOptions.length)];
          if (walkClip) {
            this.walkAction = this.mixer.clipAction(walkClip);
            this.walkAction.setEffectiveTimeScale(1.0 + Math.random() * 0.2);
          }
        }
      }

      lerpAngle(from, to, t) {
        let diff = to - from;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return from + diff * Math.min(t, 1);
      }

      pickNextWaypoint() {
        const possibleNext = connections[this.currentWaypoint];
        if (!possibleNext || possibleNext.length === 0) return null;

        // Prefer waypoints we haven't just come from
        let choices = possibleNext.filter(w => w !== this.lastWaypoint);
        if (choices.length === 0) choices = possibleNext;

        return choices[Math.floor(Math.random() * choices.length)];
      }

      update(delta) {
        this.mixer.update(delta);
        this.stateTime += delta;

        switch (this.state) {
          case 'idle':
            // Small idle movements
            if (Math.random() < 0.003) {
              this.model.rotation.y += (Math.random() - 0.5) * 0.3;
            }

            if (this.stateTime > this.idleDuration) {
              this.targetWaypoint = this.pickNextWaypoint();
              if (this.targetWaypoint) {
                this.state = 'turning';
                this.stateTime = 0;
              }
            }
            break;

          case 'turning':
            const target = waypoints[this.targetWaypoint];
            const dx = target.x - this.model.position.x;
            const dz = target.z - this.model.position.z;
            const targetAngle = Math.atan2(dx, dz);

            this.model.rotation.y = this.lerpAngle(this.model.rotation.y, targetAngle, delta * this.turnSpeed);

            let angleDiff = Math.abs(targetAngle - this.model.rotation.y);
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

            if (Math.abs(angleDiff) < 0.15) {
              this.state = 'walking';
              this.stateTime = 0;
              if (this.walkAction && this.idleAction) {
                this.idleAction.fadeOut(0.3);
                this.walkAction.reset().fadeIn(0.3).play();
              }
            }
            break;

          case 'walking':
            const dest = waypoints[this.targetWaypoint];
            const dirX = dest.x - this.model.position.x;
            const dirZ = dest.z - this.model.position.z;
            const dist = Math.sqrt(dirX * dirX + dirZ * dirZ);

            // Accelerate/decelerate based on distance
            if (dist > 2) {
              this.currentSpeed = Math.min(this.currentSpeed + this.acceleration * delta, this.maxSpeed);
            } else {
              this.currentSpeed = Math.max(this.currentSpeed - this.deceleration * delta, 0.3);
            }

            if (dist > 0.3) {
              const moveX = (dirX / dist) * this.currentSpeed * delta;
              const moveZ = (dirZ / dist) * this.currentSpeed * delta;
              this.model.position.x += moveX;
              this.model.position.z += moveZ;

              // Face movement direction smoothly
              const moveAngle = Math.atan2(dirX, dirZ);
              this.model.rotation.y = this.lerpAngle(this.model.rotation.y, moveAngle, delta * this.turnSpeed * 0.5);

              // Walking bob
              const bob = Math.sin(this.stateTime * 10) * 0.01 * (this.currentSpeed / this.maxSpeed);
              this.model.position.y = bob;
            } else {
              // Arrived at waypoint
              this.lastWaypoint = this.currentWaypoint;
              this.currentWaypoint = this.targetWaypoint;
              this.targetWaypoint = null;
              this.currentSpeed = 0;
              this.model.position.y = 0;

              this.state = 'idle';
              this.stateTime = 0;
              this.idleDuration = 1 + Math.random() * 3;

              if (this.idleAction && this.walkAction) {
                this.walkAction.fadeOut(0.4);
                this.idleAction.reset().fadeIn(0.4).play();
              }
            }
            break;
        }
      }
    }

    // ==================== LOADERS ====================
    function loadCharacter(name, startWaypoint, rig = 'medium', scale = 1) {
      totalToLoad++;
      const pos = waypoints[startWaypoint];
      gltfLoader.load(`assets/models/${name}.glb`, (gltf) => {
        const model = gltf.scene;
        model.position.set(pos.x, 0, pos.z);
        model.scale.set(scale, scale, scale);
        model.rotation.y = Math.random() * Math.PI * 2;
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        scene.add(model);
        characters.push(new Character(model, rig, startWaypoint));
        updateLoading();
      }, undefined, () => updateLoading());
    }

    function loadTownAsset(category, name, position, scale = 1, rotation = 0) {
      totalToLoad++;
      gltfLoader.load(`assets/town/${category}/${name}.gltf`, (gltf) => {
        const model = gltf.scene;
        model.position.set(position.x, position.y, position.z);
        model.scale.set(scale, scale, scale);
        model.rotation.y = rotation;
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        scene.add(model);
        updateLoading();
      }, undefined, () => updateLoading());
    }

    // ==================== BUILD TOWN ====================
    async function buildTown() {
      await loadAnimations();

      // === GROUND TILES ===
      const hexW = 1.73, hexH = 1.5;
      for (let x = -6; x <= 6; x++) {
        for (let z = -6; z <= 6; z++) {
          const offX = z % 2 === 0 ? 0 : hexW / 2;
          const px = x * hexW + offX, pz = z * hexH;

          // Road pattern - main cross + side streets
          const isMainRoad = (Math.abs(x) <= 1 && Math.abs(z) <= 6) || (Math.abs(z) <= 1 && Math.abs(x) <= 6);
          const isSideStreet = (Math.abs(x) >= 2 && Math.abs(x) <= 4 && Math.abs(z) === 3) ||
                               (Math.abs(z) >= 2 && Math.abs(z) <= 4 && Math.abs(x) === 3);

          if (isMainRoad || isSideStreet) {
            loadTownAsset('tiles', 'hex_road_A', { x: px, y: 0.01, z: pz }, 1);
          } else {
            loadTownAsset('tiles', 'hex_grass', { x: px, y: 0, z: pz }, 1);
          }
        }
      }

      // === HOUSES - Northwest District (Tavern Area) ===
      loadTownAsset('buildings', 'building_stage_A', { x: -6, y: 0, z: -5 }, 1.3, Math.PI/4);
      loadTownAsset('buildings', 'building_stage_B', { x: -8, y: 0, z: -4 }, 1.2, Math.PI/3);
      loadTownAsset('buildings', 'building_stage_C', { x: -7, y: 0, z: -7 }, 1.1, Math.PI/5);
      loadTownAsset('buildings', 'building_grain', { x: -5, y: 0, z: -7 }, 1.0, Math.PI/6);

      // === HOUSES - Northeast District (Market Area) ===
      loadTownAsset('buildings', 'building_stage_A', { x: 6, y: 0, z: -5 }, 1.3, -Math.PI/4);
      loadTownAsset('buildings', 'building_stage_B', { x: 8, y: 0, z: -4 }, 1.2, -Math.PI/3);
      loadTownAsset('buildings', 'building_stage_C', { x: 7, y: 0, z: -7 }, 1.1, -Math.PI/5);
      loadTownAsset('buildings', 'building_grain', { x: 5, y: 0, z: -7 }, 1.0, -Math.PI/6);

      // === HOUSES - Southwest District (Residential) ===
      loadTownAsset('buildings', 'building_stage_A', { x: -6, y: 0, z: 5 }, 1.2, Math.PI * 0.75);
      loadTownAsset('buildings', 'building_stage_B', { x: -8, y: 0, z: 4 }, 1.1, Math.PI * 0.6);
      loadTownAsset('buildings', 'building_stage_C', { x: -7, y: 0, z: 7 }, 1.3, Math.PI * 0.8);
      loadTownAsset('buildings', 'building_dirt', { x: -5, y: 0, z: 7 }, 1.0, Math.PI * 0.7);

      // === HOUSES - Southeast District (Residential) ===
      loadTownAsset('buildings', 'building_stage_A', { x: 6, y: 0, z: 5 }, 1.2, -Math.PI * 0.75);
      loadTownAsset('buildings', 'building_stage_B', { x: 8, y: 0, z: 4 }, 1.1, -Math.PI * 0.6);
      loadTownAsset('buildings', 'building_stage_C', { x: 7, y: 0, z: 7 }, 1.3, -Math.PI * 0.8);
      loadTownAsset('buildings', 'building_grain', { x: 5, y: 0, z: 7 }, 1.0, -Math.PI * 0.7);

      // === CENTRAL PLAZA ===
      loadTownAsset('buildings', 'building_scaffolding', { x: 0, y: 0, z: 0 }, 1.8, 0);
      loadTownAsset('props', 'flag_blue', { x: -1.5, y: 0, z: -1.5 }, 1.5);
      loadTownAsset('props', 'flag_red', { x: 1.5, y: 0, z: -1.5 }, 1.5);
      loadTownAsset('props', 'flag_green', { x: -1.5, y: 0, z: 1.5 }, 1.5);
      loadTownAsset('props', 'flag_yellow', { x: 1.5, y: 0, z: 1.5 }, 1.5);

      // === WALLS ===
      for (let i = -4; i <= 4; i++) {
        loadTownAsset('buildings', 'wall_straight', { x: i * 2.5, y: 0, z: -12 }, 1, 0);
        loadTownAsset('buildings', 'wall_straight', { x: i * 2.5, y: 0, z: 12 }, 1, Math.PI);
        loadTownAsset('buildings', 'wall_straight', { x: -12, y: 0, z: i * 2.5 }, 1, -Math.PI/2);
        loadTownAsset('buildings', 'wall_straight', { x: 12, y: 0, z: i * 2.5 }, 1, Math.PI/2);
      }

      // Corner towers
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: -12, y: 0, z: -12 }, 1.4, 0);
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: 12, y: 0, z: -12 }, 1.4, Math.PI/2);
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: 12, y: 0, z: 12 }, 1.4, Math.PI);
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: -12, y: 0, z: 12 }, 1.4, -Math.PI/2);

      // Gates
      loadTownAsset('buildings', 'wall_straight_gate', { x: 0, y: 0, z: -12 }, 1.3, 0);
      loadTownAsset('buildings', 'wall_straight_gate', { x: 0, y: 0, z: 12 }, 1.3, Math.PI);
      loadTownAsset('buildings', 'wall_straight_gate', { x: -12, y: 0, z: 0 }, 1.3, -Math.PI/2);
      loadTownAsset('buildings', 'wall_straight_gate', { x: 12, y: 0, z: 0 }, 1.3, Math.PI/2);

      // === MARKET PROPS ===
      loadTownAsset('props', 'barrel', { x: 5.5, y: 0, z: -4.5 }, 1);
      loadTownAsset('props', 'barrel', { x: 6, y: 0, z: -4.2 }, 1);
      loadTownAsset('props', 'crate_A_big', { x: 6.5, y: 0, z: -5 }, 1);
      loadTownAsset('props', 'crate_B_big', { x: 7, y: 0, z: -4.5 }, 1);
      loadTownAsset('props', 'sack', { x: 5.8, y: 0, z: -5.2 }, 1);
      loadTownAsset('props', 'sack', { x: 6.2, y: 0, z: -5.5 }, 1);
      loadTownAsset('props', 'tent', { x: 7.5, y: 0, z: -6 }, 1.2, -Math.PI/4);

      // === TAVERN PROPS ===
      loadTownAsset('props', 'barrel', { x: -5.5, y: 0, z: -4.5 }, 1);
      loadTownAsset('props', 'barrel', { x: -6, y: 0, z: -4.2 }, 1);
      loadTownAsset('props', 'barrel', { x: -5.2, y: 0, z: -4 }, 1);
      loadTownAsset('props', 'bucket_water', { x: -6.5, y: 0, z: -5 }, 1);
      loadTownAsset('props', 'crate_long_A', { x: -7, y: 0, z: -5.5 }, 1);

      // === RESIDENTIAL PROPS ===
      loadTownAsset('props', 'wheelbarrow', { x: -6.5, y: 0, z: 4 }, 1, Math.PI/3);
      loadTownAsset('props', 'bucket_empty', { x: -5.5, y: 0, z: 5.5 }, 1);
      loadTownAsset('props', 'pallet', { x: -7, y: 0, z: 5 }, 1);
      loadTownAsset('props', 'resource_lumber', { x: -7, y: 0.1, z: 5 }, 1);
      loadTownAsset('props', 'ladder', { x: 6.5, y: 0, z: 5.5 }, 1, -Math.PI/4);
      loadTownAsset('props', 'crate_open', { x: 7, y: 0, z: 4.5 }, 1);

      // === TRAINING AREA ===
      loadTownAsset('props', 'target', { x: 9, y: 0, z: 4 }, 1);
      loadTownAsset('props', 'target', { x: 9, y: 0, z: 6 }, 1);
      loadTownAsset('props', 'weaponrack', { x: 8, y: 0, z: 3 }, 1, -Math.PI/2);
      loadTownAsset('props', 'bucket_arrows', { x: 8.5, y: 0, z: 5 }, 1);

      // === FENCES ===
      loadTownAsset('buildings', 'fence_wood_straight', { x: -4, y: 0, z: 3.5 }, 1, Math.PI/2);
      loadTownAsset('buildings', 'fence_wood_straight_gate', { x: -4, y: 0, z: 5 }, 1, Math.PI/2);
      loadTownAsset('buildings', 'fence_stone_straight', { x: 4, y: 0, z: -3.5 }, 1, Math.PI/2);

      // === NATURE - Inside Town ===
      loadTownAsset('nature', 'tree_single_A', { x: -3, y: 0, z: -3 }, 1);
      loadTownAsset('nature', 'tree_single_B', { x: 3, y: 0, z: 3 }, 1);
      loadTownAsset('nature', 'tree_single_A', { x: -8, y: 0, z: 0 }, 0.9);
      loadTownAsset('nature', 'tree_single_B', { x: 8, y: 0, z: 0 }, 0.9);
      loadTownAsset('nature', 'rock_single_A', { x: -9, y: 0, z: -8 }, 0.8);
      loadTownAsset('nature', 'rock_single_B', { x: 9, y: 0, z: 8 }, 0.8);

      // === NATURE - Outside Walls ===
      loadTownAsset('nature', 'trees_A_large', { x: -18, y: 0, z: -10 }, 1.3);
      loadTownAsset('nature', 'trees_B_large', { x: -18, y: 0, z: 0 }, 1.2);
      loadTownAsset('nature', 'trees_A_medium', { x: -18, y: 0, z: 10 }, 1.4);
      loadTownAsset('nature', 'trees_B_large', { x: 18, y: 0, z: -10 }, 1.3);
      loadTownAsset('nature', 'trees_A_large', { x: 18, y: 0, z: 0 }, 1.2);
      loadTownAsset('nature', 'trees_B_medium', { x: 18, y: 0, z: 10 }, 1.4);
      loadTownAsset('nature', 'trees_A_large', { x: 0, y: 0, z: -20 }, 1.5);
      loadTownAsset('nature', 'trees_B_large', { x: 0, y: 0, z: 20 }, 1.5);

      // Hills & Mountains
      loadTownAsset('nature', 'hills_A_trees', { x: -30, y: 0, z: 0 }, 2.5);
      loadTownAsset('nature', 'hills_B_trees', { x: 30, y: 0, z: 0 }, 2.5);
      loadTownAsset('nature', 'hills_C_trees', { x: 0, y: 0, z: -30 }, 2.5);
      loadTownAsset('nature', 'mountain_A_grass_trees', { x: -40, y: 0, z: -25 }, 4);
      loadTownAsset('nature', 'mountain_B_grass_trees', { x: 40, y: 0, z: -25 }, 4);
      loadTownAsset('nature', 'mountain_C_grass', { x: 0, y: 0, z: -45 }, 5);

      // Clouds
      loadTownAsset('nature', 'cloud_big', { x: -20, y: 25, z: -15 }, 4);
      loadTownAsset('nature', 'cloud_small', { x: 15, y: 28, z: 10 }, 3);
      loadTownAsset('nature', 'cloud_big', { x: 25, y: 22, z: -20 }, 3.5);
      loadTownAsset('nature', 'cloud_small', { x: -10, y: 30, z: 20 }, 2.5);

      // === CHARACTERS - Walking the roads ===
      // Townspeople on main routes
      loadCharacter('BlackKnight', 'center', 'medium', 1);
      loadCharacter('Witch', 'northPlaza', 'medium', 1);
      loadCharacter('Vampire', 'southPlaza', 'medium', 1);
      loadCharacter('Hiker', 'westPlaza', 'medium', 1);
      loadCharacter('Tiefling', 'eastPlaza', 'medium', 1);

      // Tavern district regulars
      loadCharacter('Caveman', 'tavernFront', 'medium', 1);
      loadCharacter('Helper_A', 'tavernBack', 'medium', 1);

      // Market shoppers
      loadCharacter('Helper_B', 'marketFront', 'medium', 1);
      loadCharacter('Protagonist_A', 'marketBack', 'medium', 1);

      // Residential wanderers
      loadCharacter('Superhero', 'houseWest1', 'medium', 1);
      loadCharacter('Protagonist_B', 'houseEast1', 'medium', 1);

      // Gate guards (larger, slower)
      loadCharacter('FrostGolem', 'northGate', 'large', 1.2);
      loadCharacter('CombatMech', 'southGate', 'large', 1.2);
      loadCharacter('Clanker', 'westGate', 'large', 1.2);
    }

    // Start
    buildTown();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      for (const char of characters) char.update(delta);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
