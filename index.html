<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eliza Town</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a2e; }
    canvas { display: block; }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
      text-align: center;
      z-index: 100;
    }
    #loading .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #333;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 10px 15px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div>Loading Eliza Town...</div>
  </div>
  <div id="info">
    Mouse: Rotate | Scroll: Zoom | Right-click drag: Pan
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x7EC8E3);
    scene.fog = new THREE.FogExp2(0x7EC8E3, 0.015);

    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(25, 18, 25);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 5;
    controls.maxDistance = 60;
    controls.target.set(0, 0, 0);

    // Lighting - warm sunlight
    const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.5);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.5);
    sunLight.position.set(30, 40, 20);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 150;
    sunLight.shadow.camera.left = -50;
    sunLight.shadow.camera.right = 50;
    sunLight.shadow.camera.top = 50;
    sunLight.shadow.camera.bottom = -50;
    sunLight.shadow.bias = -0.0001;
    scene.add(sunLight);

    // Fill light from opposite side
    const fillLight = new THREE.DirectionalLight(0x8ecae6, 0.3);
    fillLight.position.set(-20, 10, -20);
    scene.add(fillLight);

    // Ground - larger grassy area
    const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a7c4e,
      roughness: 0.9,
      metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.05;
    ground.receiveShadow = true;
    scene.add(ground);

    // Loaders
    const gltfLoader = new GLTFLoader();
    const clock = new THREE.Clock();

    let loadedCount = 0;
    let totalToLoad = 0;
    const mixers = [];
    const characters = [];
    const animationClips = { medium: null, large: null };

    function updateLoading() {
      loadedCount++;
      const loadingEl = document.getElementById('loading');
      if (loadedCount >= totalToLoad && loadingEl) {
        loadingEl.style.display = 'none';
      }
    }

    // Load animations first
    async function loadAnimations() {
      return new Promise((resolve) => {
        let loaded = 0;

        gltfLoader.load('assets/animations/rig_medium/General.glb', (gltf) => {
          animationClips.medium = gltf.animations;
          loaded++;
          if (loaded === 2) resolve();
        });

        gltfLoader.load('assets/animations/rig_large/General.glb', (gltf) => {
          animationClips.large = gltf.animations;
          loaded++;
          if (loaded === 2) resolve();
        });
      });
    }

    // Character class with natural movement AI
    class Character {
      constructor(model, rig, startPos, wanderRadius = 5) {
        this.model = model;
        this.rig = rig;
        this.mixer = new THREE.AnimationMixer(model);
        this.homePosition = new THREE.Vector3(startPos.x, startPos.y, startPos.z);
        this.targetPosition = this.homePosition.clone();
        this.wanderRadius = wanderRadius;

        // Natural movement parameters
        this.maxSpeed = 1.2 + Math.random() * 0.6;
        this.currentSpeed = 0;
        this.acceleration = 2.0;
        this.deceleration = 3.0;
        this.turnSpeed = 4.0 + Math.random() * 2;
        this.targetRotation = model.rotation.y;

        // State management
        this.state = 'idle';
        this.stateTime = 0;
        this.idleDuration = 3 + Math.random() * 5;
        this.turningFirst = false;

        // Subtle idle motion
        this.bobOffset = Math.random() * Math.PI * 2;
        this.bobSpeed = 1.5 + Math.random() * 0.5;
        this.swayAmount = 0.02 + Math.random() * 0.02;
        this.baseY = startPos.y;

        // Apply animations
        const clips = rig === 'large' ? animationClips.large : animationClips.medium;
        if (clips && clips.length > 0) {
          // Find idle animation
          const idleClip = clips.find(c => c.name.toLowerCase().includes('idle')) || clips[0];
          if (idleClip) {
            this.idleAction = this.mixer.clipAction(idleClip);
            this.idleAction.setEffectiveTimeScale(0.8 + Math.random() * 0.4);
            this.idleAction.play();
          }

          // Find walk animation
          const walkClip = clips.find(c => c.name.toLowerCase().includes('walk'));
          if (walkClip) {
            this.walkAction = this.mixer.clipAction(walkClip);
            this.walkAction.setEffectiveTimeScale(0.9 + Math.random() * 0.2);
          }
        }

        mixers.push(this.mixer);
      }

      // Smooth angle interpolation
      lerpAngle(from, to, t) {
        let diff = to - from;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return from + diff * t;
      }

      // Ease in-out function for smooth acceleration
      easeInOut(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      }

      update(delta) {
        this.mixer.update(delta);
        this.stateTime += delta;

        // Subtle breathing/sway motion when idle
        if (this.state === 'idle') {
          const bob = Math.sin(this.stateTime * this.bobSpeed + this.bobOffset) * this.swayAmount;
          this.model.position.y = this.baseY + Math.abs(bob) * 0.05;

          // Occasional small rotation shifts
          if (Math.random() < 0.002) {
            this.targetRotation += (Math.random() - 0.5) * 0.5;
          }

          // Smooth rotation even when idle
          this.model.rotation.y = this.lerpAngle(
            this.model.rotation.y,
            this.targetRotation,
            delta * 2
          );
        }

        // State machine
        switch (this.state) {
          case 'idle':
            if (this.stateTime > this.idleDuration) {
              this.pickNewTarget();
              this.state = 'turning';
              this.stateTime = 0;
            }
            break;

          case 'turning':
            // Calculate target rotation
            const dirToTarget = new THREE.Vector3()
              .subVectors(this.targetPosition, this.model.position);
            this.targetRotation = Math.atan2(dirToTarget.x, dirToTarget.z);

            // Smoothly turn towards target
            this.model.rotation.y = this.lerpAngle(
              this.model.rotation.y,
              this.targetRotation,
              delta * this.turnSpeed
            );

            // Check if we're facing the right direction
            let angleDiff = Math.abs(this.targetRotation - this.model.rotation.y);
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            angleDiff = Math.abs(angleDiff);

            if (angleDiff < 0.2) {
              this.state = 'accelerating';
              this.stateTime = 0;

              // Start walk animation
              if (this.walkAction && this.idleAction) {
                this.idleAction.fadeOut(0.4);
                this.walkAction.reset().fadeIn(0.4).play();
              }
            }
            break;

          case 'accelerating':
            // Smoothly accelerate
            this.currentSpeed = Math.min(this.currentSpeed + this.acceleration * delta, this.maxSpeed);
            this.moveTowardsTarget(delta);

            // Check if at full speed or close to target
            const distToTarget = this.model.position.distanceTo(this.targetPosition);
            if (distToTarget < 2) {
              this.state = 'decelerating';
              this.stateTime = 0;
            }
            break;

          case 'decelerating':
            // Smoothly decelerate
            this.currentSpeed = Math.max(this.currentSpeed - this.deceleration * delta, 0);
            this.moveTowardsTarget(delta);

            if (this.currentSpeed <= 0.05 || this.model.position.distanceTo(this.targetPosition) < 0.2) {
              this.state = 'idle';
              this.stateTime = 0;
              this.currentSpeed = 0;
              this.idleDuration = 2 + Math.random() * 6;

              // Return to idle animation
              if (this.idleAction && this.walkAction) {
                this.walkAction.fadeOut(0.5);
                this.idleAction.reset().fadeIn(0.5).play();
              }
            }
            break;
        }
      }

      moveTowardsTarget(delta) {
        const direction = new THREE.Vector3()
          .subVectors(this.targetPosition, this.model.position)
          .normalize();

        // Move with current speed
        this.model.position.x += direction.x * this.currentSpeed * delta;
        this.model.position.z += direction.z * this.currentSpeed * delta;

        // Smooth rotation while walking
        const targetAngle = Math.atan2(direction.x, direction.z);
        this.model.rotation.y = this.lerpAngle(
          this.model.rotation.y,
          targetAngle,
          delta * this.turnSpeed * 0.5
        );

        // Subtle walking bob
        const walkBob = Math.sin(this.stateTime * 8) * 0.015 * (this.currentSpeed / this.maxSpeed);
        this.model.position.y = this.baseY + walkBob;
      }

      pickNewTarget() {
        // More natural target selection - prefer shorter distances sometimes
        const distance = Math.pow(Math.random(), 0.7) * this.wanderRadius;
        const angle = Math.random() * Math.PI * 2;

        this.targetPosition.set(
          this.homePosition.x + Math.cos(angle) * distance,
          0,
          this.homePosition.z + Math.sin(angle) * distance
        );
      }
    }

    // Load character with animation
    function loadCharacter(name, position, rig = 'medium', scale = 1, wanderRadius = 4) {
      totalToLoad++;
      gltfLoader.load(
        `assets/models/${name}.glb`,
        (gltf) => {
          const model = gltf.scene;
          model.position.set(position.x, position.y, position.z);
          model.scale.set(scale, scale, scale);
          model.rotation.y = Math.random() * Math.PI * 2;
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(model);

          const character = new Character(model, rig, position, wanderRadius);
          characters.push(character);

          updateLoading();
        },
        undefined,
        () => updateLoading()
      );
    }

    // Load town asset
    function loadTownAsset(category, name, position, scale = 1, rotation = 0) {
      totalToLoad++;
      gltfLoader.load(
        `assets/town/${category}/${name}.gltf`,
        (gltf) => {
          const model = gltf.scene;
          model.position.set(position.x, position.y, position.z);
          model.scale.set(scale, scale, scale);
          model.rotation.y = rotation;
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(model);
          updateLoading();
        },
        undefined,
        () => updateLoading()
      );
    }

    // Build the town
    async function buildTown() {
      await loadAnimations();

      // === GROUND TILES - Create larger town area ===
      const hexWidth = 1.73;
      const hexHeight = 1.5;

      // Main town area tiles
      for (let x = -5; x <= 5; x++) {
        for (let z = -5; z <= 5; z++) {
          const offsetX = z % 2 === 0 ? 0 : hexWidth / 2;
          const posX = x * hexWidth + offsetX;
          const posZ = z * hexHeight;

          // Roads in center cross pattern
          if ((Math.abs(x) <= 1 && Math.abs(z) <= 3) || (Math.abs(z) <= 1 && Math.abs(x) <= 3)) {
            loadTownAsset('tiles', 'hex_road_A', { x: posX, y: 0.01, z: posZ }, 1);
          } else {
            loadTownAsset('tiles', 'hex_grass', { x: posX, y: 0, z: posZ }, 1);
          }
        }
      }

      // === MAIN BUILDINGS - Town Center ===
      // Tavern/Inn area
      loadTownAsset('buildings', 'building_stage_A', { x: -6, y: 0, z: -5 }, 1.2, Math.PI/4);
      loadTownAsset('buildings', 'building_stage_B', { x: -4, y: 0, z: -6 }, 1.2, Math.PI/6);
      loadTownAsset('buildings', 'building_stage_C', { x: -7, y: 0, z: -3 }, 1, 0);

      // Market/Shop area
      loadTownAsset('buildings', 'building_stage_A', { x: 6, y: 0, z: -5 }, 1.2, -Math.PI/4);
      loadTownAsset('buildings', 'building_stage_B', { x: 4, y: 0, z: -6 }, 1.2, -Math.PI/6);
      loadTownAsset('buildings', 'building_grain', { x: 7, y: 0, z: -3 }, 1.2, -Math.PI/3);

      // Storage buildings
      loadTownAsset('buildings', 'building_grain', { x: -6, y: 0, z: 5 }, 1.2, Math.PI/3);
      loadTownAsset('buildings', 'building_dirt', { x: -4, y: 0, z: 6 }, 1, Math.PI/4);
      loadTownAsset('buildings', 'building_stage_C', { x: 6, y: 0, z: 5 }, 1, -Math.PI/4);

      // Central plaza feature
      loadTownAsset('buildings', 'building_scaffolding', { x: 0, y: 0, z: 0 }, 1.5, 0);

      // Bridges
      loadTownAsset('buildings', 'building_bridge_A', { x: -8, y: 0, z: 0 }, 1.2, Math.PI/2);
      loadTownAsset('buildings', 'building_bridge_B', { x: 8, y: 0, z: 0 }, 1.2, -Math.PI/2);

      // === WALLS - Surrounding the town ===
      // North wall
      for (let i = -3; i <= 3; i++) {
        loadTownAsset('buildings', 'wall_straight', { x: i * 2.5, y: 0, z: -10 }, 1, 0);
      }
      // South wall
      for (let i = -3; i <= 3; i++) {
        loadTownAsset('buildings', 'wall_straight', { x: i * 2.5, y: 0, z: 10 }, 1, Math.PI);
      }
      // East wall
      for (let i = -3; i <= 3; i++) {
        loadTownAsset('buildings', 'wall_straight', { x: 10, y: 0, z: i * 2.5 }, 1, Math.PI/2);
      }
      // West wall
      for (let i = -3; i <= 3; i++) {
        loadTownAsset('buildings', 'wall_straight', { x: -10, y: 0, z: i * 2.5 }, 1, -Math.PI/2);
      }

      // Corner towers
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: -10, y: 0, z: -10 }, 1.3, 0);
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: 10, y: 0, z: -10 }, 1.3, Math.PI/2);
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: 10, y: 0, z: 10 }, 1.3, Math.PI);
      loadTownAsset('buildings', 'wall_corner_A_outside', { x: -10, y: 0, z: 10 }, 1.3, -Math.PI/2);

      // Gates
      loadTownAsset('buildings', 'wall_straight_gate', { x: 0, y: 0, z: -10 }, 1.2, 0);
      loadTownAsset('buildings', 'wall_straight_gate', { x: 0, y: 0, z: 10 }, 1.2, Math.PI);

      // === FENCES - Inner areas ===
      loadTownAsset('buildings', 'fence_wood_straight', { x: -3, y: 0, z: 3 }, 1);
      loadTownAsset('buildings', 'fence_wood_straight', { x: -4.5, y: 0, z: 3 }, 1);
      loadTownAsset('buildings', 'fence_wood_straight_gate', { x: -1.5, y: 0, z: 3 }, 1);
      loadTownAsset('buildings', 'fence_stone_straight', { x: 3, y: 0, z: -3 }, 1);
      loadTownAsset('buildings', 'fence_stone_straight', { x: 4.5, y: 0, z: -3 }, 1);

      // === PROPS - Scattered throughout ===
      // Market area props
      loadTownAsset('props', 'barrel', { x: 5, y: 0, z: -4 }, 1);
      loadTownAsset('props', 'barrel', { x: 5.3, y: 0, z: -3.7 }, 1);
      loadTownAsset('props', 'barrel', { x: 5.6, y: 0, z: -4.1 }, 1);
      loadTownAsset('props', 'crate_A_big', { x: 6.5, y: 0, z: -4 }, 1);
      loadTownAsset('props', 'crate_A_small', { x: 6.8, y: 0.4, z: -4 }, 1);
      loadTownAsset('props', 'crate_B_big', { x: 7, y: 0, z: -4.5 }, 1);
      loadTownAsset('props', 'sack', { x: 6.2, y: 0, z: -4.5 }, 1);
      loadTownAsset('props', 'sack', { x: 6.5, y: 0, z: -4.7 }, 1);

      // Tavern area props
      loadTownAsset('props', 'barrel', { x: -5, y: 0, z: -4 }, 1);
      loadTownAsset('props', 'barrel', { x: -5.4, y: 0, z: -4.2 }, 1);
      loadTownAsset('props', 'bucket_water', { x: -4.5, y: 0, z: -4 }, 1);
      loadTownAsset('props', 'crate_long_A', { x: -6, y: 0, z: -4.5 }, 1);

      // Storage area props
      loadTownAsset('props', 'crate_long_B', { x: -5, y: 0, z: 4.5 }, 1);
      loadTownAsset('props', 'crate_long_C', { x: -5, y: 0, z: 5.5 }, 1);
      loadTownAsset('props', 'pallet', { x: -6.5, y: 0, z: 4 }, 1);
      loadTownAsset('props', 'resource_lumber', { x: -6.5, y: 0.1, z: 4 }, 1);
      loadTownAsset('props', 'wheelbarrow', { x: -3, y: 0, z: 5 }, 1, Math.PI/4);

      // Central plaza props
      loadTownAsset('props', 'flag_blue', { x: -2, y: 0, z: 0 }, 1.5);
      loadTownAsset('props', 'flag_red', { x: 2, y: 0, z: 0 }, 1.5);
      loadTownAsset('props', 'bucket_empty', { x: 1, y: 0, z: 1 }, 1);

      // Training area
      loadTownAsset('props', 'target', { x: 8, y: 0, z: 4 }, 1);
      loadTownAsset('props', 'target', { x: 8, y: 0, z: 5.5 }, 1);
      loadTownAsset('props', 'weaponrack', { x: 7, y: 0, z: 3 }, 1, -Math.PI/2);
      loadTownAsset('props', 'bucket_arrows', { x: 7.5, y: 0, z: 4.5 }, 1);

      // Camp area
      loadTownAsset('props', 'tent', { x: -7, y: 0, z: 7 }, 1.2, Math.PI/6);
      loadTownAsset('props', 'tent', { x: -5, y: 0, z: 8 }, 1, -Math.PI/4);
      loadTownAsset('props', 'ladder', { x: -8, y: 0, z: 5 }, 1, Math.PI/3);

      // Guard posts
      loadTownAsset('props', 'flag_yellow', { x: -10, y: 0, z: -10 }, 1.5);
      loadTownAsset('props', 'flag_green', { x: 10, y: 0, z: -10 }, 1.5);

      // === NATURE - Trees and scenery ===
      // Forest outside walls
      loadTownAsset('nature', 'trees_A_large', { x: -15, y: 0, z: -8 }, 1.2);
      loadTownAsset('nature', 'trees_B_large', { x: -14, y: 0, z: -4 }, 1);
      loadTownAsset('nature', 'trees_A_medium', { x: -15, y: 0, z: 0 }, 1.1);
      loadTownAsset('nature', 'trees_B_medium', { x: -14, y: 0, z: 5 }, 1);
      loadTownAsset('nature', 'trees_A_large', { x: -15, y: 0, z: 10 }, 1.3);

      loadTownAsset('nature', 'trees_B_large', { x: 15, y: 0, z: -8 }, 1.2);
      loadTownAsset('nature', 'trees_A_medium', { x: 14, y: 0, z: -2 }, 1.1);
      loadTownAsset('nature', 'trees_B_medium', { x: 15, y: 0, z: 3 }, 1);
      loadTownAsset('nature', 'trees_A_large', { x: 14, y: 0, z: 8 }, 1.2);

      // Trees inside town
      loadTownAsset('nature', 'tree_single_A', { x: -3, y: 0, z: -3 }, 1);
      loadTownAsset('nature', 'tree_single_B', { x: 3, y: 0, z: 4 }, 1);
      loadTownAsset('nature', 'tree_single_A', { x: -7, y: 0, z: 2 }, 0.9);
      loadTownAsset('nature', 'tree_single_B', { x: 7, y: 0, z: -1 }, 0.8);

      // Distant trees/forests
      loadTownAsset('nature', 'trees_A_large', { x: -20, y: 0, z: -15 }, 1.5);
      loadTownAsset('nature', 'trees_B_large', { x: 20, y: 0, z: -15 }, 1.5);
      loadTownAsset('nature', 'trees_A_large', { x: -20, y: 0, z: 15 }, 1.4);
      loadTownAsset('nature', 'trees_B_large', { x: 20, y: 0, z: 15 }, 1.4);
      loadTownAsset('nature', 'trees_A_medium', { x: 0, y: 0, z: -18 }, 1.3);
      loadTownAsset('nature', 'trees_B_medium', { x: 0, y: 0, z: 18 }, 1.3);

      // Hills in background
      loadTownAsset('nature', 'hills_A_trees', { x: -25, y: 0, z: 0 }, 2);
      loadTownAsset('nature', 'hills_B_trees', { x: 25, y: 0, z: 0 }, 2);
      loadTownAsset('nature', 'hills_C_trees', { x: 0, y: 0, z: -25 }, 2);
      loadTownAsset('nature', 'hill_single_A', { x: -18, y: 0, z: -18 }, 1.5);
      loadTownAsset('nature', 'hill_single_B', { x: 18, y: 0, z: -18 }, 1.5);
      loadTownAsset('nature', 'hill_single_C', { x: 0, y: 0, z: 25 }, 1.8);

      // Mountains far background
      loadTownAsset('nature', 'mountain_A_grass_trees', { x: -35, y: 0, z: -20 }, 3);
      loadTownAsset('nature', 'mountain_B_grass_trees', { x: 35, y: 0, z: -20 }, 3);
      loadTownAsset('nature', 'mountain_C_grass', { x: 0, y: 0, z: -35 }, 3.5);

      // Rocks scattered
      loadTownAsset('nature', 'rock_single_A', { x: -12, y: 0, z: 3 }, 1);
      loadTownAsset('nature', 'rock_single_B', { x: 12, y: 0, z: -5 }, 1);
      loadTownAsset('nature', 'rock_single_C', { x: -8, y: 0, z: -12 }, 0.8);
      loadTownAsset('nature', 'rock_single_D', { x: 9, y: 0, z: 12 }, 0.9);
      loadTownAsset('nature', 'rock_single_E', { x: -11, y: 0, z: 11 }, 1.1);

      // Clouds
      loadTownAsset('nature', 'cloud_big', { x: -15, y: 20, z: -10 }, 3);
      loadTownAsset('nature', 'cloud_small', { x: 10, y: 22, z: 5 }, 2.5);
      loadTownAsset('nature', 'cloud_big', { x: 20, y: 18, z: -15 }, 2.8);
      loadTownAsset('nature', 'cloud_small', { x: -5, y: 25, z: 15 }, 2);

      // === CHARACTERS - Living in the town ===
      // Town square - main NPCs
      loadCharacter('BlackKnight', { x: -2, y: 0, z: 1 }, 'medium', 1, 3);
      loadCharacter('Witch', { x: 2, y: 0, z: -1 }, 'medium', 1, 3);
      loadCharacter('Vampire', { x: 0, y: 0, z: -3 }, 'medium', 1, 4);

      // Tavern area patrons
      loadCharacter('Hiker', { x: -5, y: 0, z: -4 }, 'medium', 1, 3);
      loadCharacter('Caveman', { x: -6, y: 0, z: -6 }, 'medium', 1, 2);
      loadCharacter('Tiefling', { x: -4, y: 0, z: -5 }, 'medium', 1, 3);

      // Market shoppers
      loadCharacter('Helper_A', { x: 5, y: 0, z: -5 }, 'medium', 1, 3);
      loadCharacter('Helper_B', { x: 6, y: 0, z: -6 }, 'medium', 1, 2);
      loadCharacter('Protagonist_A', { x: 4, y: 0, z: -4 }, 'medium', 1, 4);

      // Training ground warriors
      loadCharacter('Superhero', { x: 7, y: 0, z: 5 }, 'medium', 1, 3);
      loadCharacter('Protagonist_B', { x: 6, y: 0, z: 4 }, 'medium', 1, 2);

      // Wall guards (stationary - large characters)
      loadCharacter('FrostGolem', { x: -10, y: 0, z: 0 }, 'large', 1.2, 1);
      loadCharacter('CombatMech', { x: 10, y: 0, z: 0 }, 'large', 1.2, 1);
      loadCharacter('Clanker', { x: 0, y: 0, z: -10 }, 'large', 1.2, 1);
    }

    // Start building
    buildTown();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Update all characters
      for (const character of characters) {
        character.update(delta);
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
