<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eliza City</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0a; font-family: 'Inter', sans-serif; }
    canvas { display: block; }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-family: 'Inter', sans-serif;
      font-size: 24px;
      text-align: center;
      z-index: 100;
    }
    #loading .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #333;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    #loading .progress {
      font-size: 14px;
      margin-top: 10px;
      color: #888;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #ccc;
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    /* Dark City UI Theme */
    #ui-container {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      max-height: calc(100vh - 20px);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
    }

    .panel {
      background: rgba(15, 15, 15, 0.95);
      border: 1px solid #333;
      border-radius: 8px;
      color: #e0e0e0;
      overflow: hidden;
    }

    .panel-header {
      background: rgba(30, 30, 30, 0.95);
      padding: 10px 14px;
      font-weight: 600;
      font-size: 13px;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #333;
    }

    .panel-header .status {
      font-size: 11px;
      padding: 3px 10px;
      border-radius: 4px;
    }

    .panel-header .status.connected { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .panel-header .status.disconnected { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

    .panel-content {
      padding: 10px;
      overflow-y: auto;
      max-height: 200px;
    }

    #agents-panel { flex: 0 0 auto; }
    #agents-panel .panel-content { display: flex; flex-direction: column; gap: 6px; }

    .agent-card {
      background: rgba(40, 40, 40, 0.8);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 8px 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.2s;
    }

    .agent-card:hover {
      background: rgba(50, 50, 50, 0.9);
      border-color: #555;
    }

    .agent-avatar {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 13px;
      color: white;
      flex-shrink: 0;
    }

    .agent-info { flex: 1; min-width: 0; }
    .agent-name { font-weight: 600; font-size: 13px; color: #fff; }
    .agent-role { font-size: 11px; color: #888; text-transform: capitalize; }

    .agent-status { font-size: 10px; padding: 3px 8px; border-radius: 4px; text-transform: capitalize; font-weight: 500; }
    .agent-status.idle { background: rgba(100, 100, 100, 0.3); color: #aaa; }
    .agent-status.working { background: rgba(34, 197, 94, 0.2); color: #22c55e; }

    #tasks-panel { flex: 0 0 auto; }
    .task-item {
      background: rgba(40, 40, 40, 0.6);
      border: 1px solid #444;
      border-left: 3px solid #3b82f6;
      border-radius: 6px;
      padding: 8px 10px;
      margin-bottom: 6px;
    }
    .task-title { font-size: 12px; font-weight: 500; color: #fff; }
    .task-meta { font-size: 10px; color: #888; margin-top: 3px; }

    #messages-panel { flex: 1; min-height: 150px; }
    #messages-panel .panel-content { display: flex; flex-direction: column; gap: 6px; }
    .message-item { background: rgba(40, 40, 40, 0.5); border: 1px solid #333; border-radius: 6px; padding: 6px 8px; font-size: 11px; }
    .message-agent { font-weight: 600; font-size: 11px; color: #3b82f6; }
    .message-content { color: #ccc; line-height: 1.4; }
    .message-type { display: inline-block; font-size: 9px; padding: 2px 6px; border-radius: 4px; margin-right: 5px; text-transform: uppercase; font-weight: 600; }
    .message-type.thought { background: rgba(139, 92, 246, 0.2); color: #a78bfa; }
    .message-type.status { background: rgba(34, 197, 94, 0.2); color: #22c55e; }

    #task-input-container {
      padding: 14px;
      background: rgba(15, 15, 15, 0.95);
      border: 1px solid #333;
      border-radius: 8px;
    }

    .input-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .input-header label { font-size: 13px; font-weight: 600; color: #fff; }
    .input-header .char-count { font-size: 10px; color: #666; }

    #task-input {
      width: 100%;
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 12px;
      color: #fff;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      resize: none;
    }
    #task-input:focus { outline: none; border-color: #3b82f6; }
    #task-input::placeholder { color: #666; }

    .button-row { display: flex; gap: 8px; margin-top: 10px; }

    #submit-task {
      flex: 1;
      padding: 10px 16px;
      background: #3b82f6;
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #submit-task:hover:not(:disabled) { background: #2563eb; }
    #submit-task:disabled { opacity: 0.5; cursor: not-allowed; background: #444; }
    #submit-task.success { background: #22c55e; }

    .priority-select {
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 10px 12px;
      color: #fff;
      font-family: 'Inter', sans-serif;
      font-size: 13px;
    }

    .server-status { display: flex; align-items: center; gap: 6px; margin-top: 8px; font-size: 10px; color: #888; }
    .server-status .dot { width: 8px; height: 8px; border-radius: 50%; background: #ef4444; }
    .server-status .dot.online { background: #22c55e; box-shadow: 0 0 8px #22c55e; }

    .panel-content::-webkit-scrollbar { width: 6px; }
    .panel-content::-webkit-scrollbar-track { background: #1a1a1a; border-radius: 3px; }
    .panel-content::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div>Loading Eliza City...</div>
    <div class="progress" id="load-progress">0%</div>
  </div>
  <div id="info">Mouse: Rotate | Scroll: Zoom | Right-click: Pan</div>

  <div id="ui-container">
    <div id="agents-panel" class="panel">
      <div class="panel-header">
        <span>Agents</span>
        <span id="ws-status" class="status disconnected">Offline</span>
      </div>
      <div class="panel-content" id="agents-list">
        <div style="color: #9b59b6; font-size: 12px; text-align: center; padding: 20px;">Connecting...</div>
      </div>
    </div>

    <div id="tasks-panel" class="panel">
      <div class="panel-header">
        <span>Active Tasks</span>
        <span id="task-count" style="font-size: 11px; color: rgba(255,255,255,0.8);">0</span>
      </div>
      <div class="panel-content" id="tasks-list">
        <div style="color: #9b59b6; font-size: 12px; text-align: center; padding: 20px;">No active tasks</div>
      </div>
    </div>

    <div id="messages-panel" class="panel">
      <div class="panel-header"><span>Activity Feed</span></div>
      <div class="panel-content" id="messages-list">
        <div style="color: #9b59b6; font-size: 12px; text-align: center; padding: 20px;">Waiting...</div>
      </div>
    </div>

    <div id="task-input-container">
      <div class="input-header">
        <label>Assign a Task</label>
        <span class="char-count"><span id="char-count">0</span>/500</span>
      </div>
      <textarea id="task-input" rows="3" placeholder="What should the team work on?" maxlength="500"></textarea>
      <div class="button-row">
        <select class="priority-select" id="priority-select">
          <option value="3">Urgent!</option>
          <option value="5" selected>Normal</option>
          <option value="7">Whenever~</option>
        </select>
        <button id="submit-task" disabled><span id="submit-text">Send Task</span></button>
      </div>
      <div class="server-status">
        <span class="dot" id="server-dot"></span>
        <span id="server-status-text">Checking server...</span>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.006);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(100, 80, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 10;
    controls.maxDistance = 300;

    // Lighting - neutral city lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
    sunLight.position.set(80, 120, 50);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -200;
    sunLight.shadow.camera.right = 200;
    sunLight.shadow.camera.top = 200;
    sunLight.shadow.camera.bottom = -200;
    scene.add(sunLight);

    const fillLight = new THREE.DirectionalLight(0xaaccff, 0.4);
    fillLight.position.set(-50, 30, -50);
    scene.add(fillLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(600, 600);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Loaders & State
    const gltfLoader = new GLTFLoader();
    const fbxLoader = new FBXLoader();
    const clock = new THREE.Clock();
    const characters = [];
    let loadedCount = 0;
    let totalToLoad = 0;

    const CITY_PATH = 'assets/models/Model packs/Assets/kenney_city-kit-commercial_2.1/Models/GLB format/';
    const HOLOMYTH_PATH = 'assets/models/Model packs/Characters/Smol Holomyth characters/';
    const COUNCILRY_PATH = 'assets/models/Model packs/Characters/beeg Smol Councilry Characters/';

    function updateProgress() {
      loadedCount++;
      const pct = Math.round((loadedCount / totalToLoad) * 100);
      document.getElementById('load-progress').textContent = `${pct}%`;
      if (loadedCount >= totalToLoad) {
        document.getElementById('loading').style.display = 'none';
      }
    }

    // City waypoints
    const waypoints = {
      center: { x: 0, z: 0 },
      north: { x: 0, z: -60 },
      south: { x: 0, z: 60 },
      east: { x: 60, z: 0 },
      west: { x: -60, z: 0 },
      ne: { x: 50, z: -50 },
      nw: { x: -50, z: -50 },
      se: { x: 50, z: 50 },
      sw: { x: -50, z: 50 },
      cafe: { x: -30, z: -20 },
      shop: { x: 30, z: -20 },
      park: { x: 0, z: 40 },
      station: { x: -55, z: 15 },
      school: { x: 55, z: -35 },
    };

    const connections = {
      center: ['north', 'south', 'east', 'west', 'cafe', 'shop', 'park'],
      north: ['center', 'ne', 'nw'],
      south: ['center', 'se', 'sw', 'park'],
      east: ['center', 'ne', 'se', 'shop', 'school'],
      west: ['center', 'nw', 'sw', 'cafe', 'station'],
      ne: ['north', 'east', 'school'],
      nw: ['north', 'west', 'cafe'],
      se: ['south', 'east'],
      sw: ['south', 'west', 'station'],
      cafe: ['center', 'west', 'nw'],
      shop: ['center', 'east'],
      park: ['center', 'south'],
      station: ['west', 'sw'],
      school: ['east', 'ne'],
    };

    // Texture loader for FBX models
    const textureLoader = new THREE.TextureLoader();

    // Character configs - Smol Holomyth and beeg Smol Councilry characters with texture mappings
    const characterModels = [
      // Smol Holomyth characters
      { name: 'Gura', model: 'Gura.fbx', path: HOLOMYTH_PATH, texture: 'textures/SmolGawrTex.png' },
      { name: 'Calli', model: 'Calli.fbx', path: HOLOMYTH_PATH, texture: 'textures/SmolCalliTex.png' },
      { name: 'Ina', model: 'Ina.fbx', path: HOLOMYTH_PATH, texture: 'textures/SmolinaTex.png' },
      { name: 'Kiara', model: 'SmolKiara.fbx', path: HOLOMYTH_PATH, texture: 'textures/SmolKiaraTex.png' },
      { name: 'Ame', model: 'Smolame.fbx', path: HOLOMYTH_PATH, texture: 'textures/SmolameTex_coat.png' },
      // beeg Smol Councilry characters
      { name: 'Kronii', model: 'SmolKronii.fbx', path: COUNCILRY_PATH, texture: 'textures/BeegSmolKronii_tex.png' },
      { name: 'Mumei', model: 'SmolMumei.fbx', path: COUNCILRY_PATH, texture: 'textures/BeegSmolMumei_tex.png' },
      { name: 'Fauna', model: 'SmolFauna.fbx', path: COUNCILRY_PATH, texture: 'textures/BeegSmolFauna_tex.png' },
      { name: 'Bae', model: 'SmolBae.fbx', path: COUNCILRY_PATH, texture: 'textures/Baeby_tex.png' },
      { name: 'IRyS', model: 'SmolIRys.fbx', path: COUNCILRY_PATH, texture: 'textures/BeegSmolIRyS_tex.png' },
      { name: 'Sana', model: 'SmolSana.fbx', path: COUNCILRY_PATH, texture: 'textures/BeegSmolSana_tex.png' },
    ];

    // Load character model (FBX) with proper textures and orientation
    function loadCharacter(config, startWaypoint) {
      totalToLoad++;
      const fullPath = config.path + config.model;
      const texturePath = config.path + config.texture;
      console.log('Loading character:', config.name, 'from', fullPath, 'texture:', texturePath);

      // Pre-load the texture
      const texture = textureLoader.load(texturePath,
        (tex) => {
          tex.flipY = false; // FBX textures often need flipY = false
          tex.colorSpace = THREE.SRGBColorSpace;
          console.log('Texture loaded for', config.name);
        },
        undefined,
        (err) => console.error('Texture load error for', config.name, err)
      );

      fbxLoader.load(fullPath, (model) => {
        console.log('Loaded:', config.name);

        // Fix FBX orientation from Blender (often exported with different up axis)
        model.rotation.x = -Math.PI / 2;

        // Scale appropriately
        model.scale.set(3, 3, 3);

        // Apply texture and configure materials
        model.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            // Apply the loaded texture to all meshes
            if (child.material) {
              // Handle array of materials
              if (Array.isArray(child.material)) {
                child.material = child.material.map(mat => {
                  const newMat = mat.clone();
                  newMat.map = texture;
                  newMat.side = THREE.DoubleSide;
                  newMat.needsUpdate = true;
                  return newMat;
                });
              } else {
                child.material = child.material.clone();
                child.material.map = texture;
                child.material.side = THREE.DoubleSide;
                child.material.needsUpdate = true;
              }
            }
          }
        });

        // Create a container group for proper rotation handling
        const characterGroup = new THREE.Group();
        characterGroup.add(model);

        const pos = waypoints[startWaypoint];
        characterGroup.position.set(pos.x, 0, pos.z);
        characterGroup.rotation.y = Math.random() * Math.PI * 2;
        scene.add(characterGroup);
        characters.push(new Character(characterGroup, startWaypoint, config));
        updateProgress();
      },
      (progress) => {
        // Progress callback
      },
      (error) => {
        console.error('Failed to load:', config.name, error);
        updateProgress();
      });
    }

    // Character class
    class Character {
      constructor(model, startWaypoint, config) {
        this.model = model;
        this.config = config;
        this.currentWaypoint = startWaypoint;
        this.targetWaypoint = null;
        this.lastWaypoint = null;
        this.maxSpeed = 3 + Math.random() * 1.5;
        this.currentSpeed = 0;
        this.turnSpeed = 4;
        this.state = 'idle';
        this.stateTime = 0;
        this.idleDuration = 2 + Math.random() * 3;
        this.bouncePhase = Math.random() * Math.PI * 2;
      }

      lerpAngle(from, to, t) {
        let diff = to - from;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return from + diff * Math.min(t, 1);
      }

      pickNextWaypoint() {
        const possibleNext = connections[this.currentWaypoint];
        if (!possibleNext) return null;
        let choices = possibleNext.filter(w => w !== this.lastWaypoint);
        if (choices.length === 0) choices = possibleNext;
        return choices[Math.floor(Math.random() * choices.length)];
      }

      update(delta) {
        this.stateTime += delta;
        this.bouncePhase += delta * 8;

        if (this.state === 'idle') {
          this.model.position.y = Math.sin(this.bouncePhase * 0.5) * 0.05;
          this.model.rotation.y += Math.sin(this.stateTime * 2) * 0.002;

          if (this.stateTime > this.idleDuration) {
            this.targetWaypoint = this.pickNextWaypoint();
            if (this.targetWaypoint) {
              this.state = 'walking';
              this.stateTime = 0;
            }
          }
        } else if (this.state === 'walking') {
          const target = waypoints[this.targetWaypoint];
          const dx = target.x - this.model.position.x;
          const dz = target.z - this.model.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          const targetAngle = Math.atan2(dx, dz);

          this.model.rotation.y = this.lerpAngle(this.model.rotation.y, targetAngle, delta * this.turnSpeed);
          this.currentSpeed = Math.min(this.currentSpeed + 5 * delta, this.maxSpeed);
          this.model.position.y = Math.abs(Math.sin(this.bouncePhase)) * 0.2;

          if (dist > 0.5) {
            this.model.position.x += (dx / dist) * this.currentSpeed * delta;
            this.model.position.z += (dz / dist) * this.currentSpeed * delta;
          } else {
            this.lastWaypoint = this.currentWaypoint;
            this.currentWaypoint = this.targetWaypoint;
            this.targetWaypoint = null;
            this.currentSpeed = 0;
            this.state = 'idle';
            this.stateTime = 0;
            this.idleDuration = 1.5 + Math.random() * 3;
            this.model.position.y = 0;
          }
        }
      }
    }

    // Load city building
    function loadBuilding(name, x, z, scale = 8, rotation = 0) {
      totalToLoad++;
      gltfLoader.load(CITY_PATH + name + '.glb', (gltf) => {
        const model = gltf.scene;
        model.position.set(x, 0, z);
        model.scale.set(scale, scale, scale);
        model.rotation.y = rotation;
        model.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        scene.add(model);
        updateProgress();
      }, undefined, () => updateProgress());
    }

    // Build city
    function buildCity() {
      // Streets
      const streetMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const mainStreetNS = new THREE.Mesh(new THREE.PlaneGeometry(20, 300), streetMat);
      mainStreetNS.rotation.x = -Math.PI / 2;
      mainStreetNS.position.y = 0.01;
      scene.add(mainStreetNS);

      const mainStreetEW = new THREE.Mesh(new THREE.PlaneGeometry(300, 20), streetMat);
      mainStreetEW.rotation.x = -Math.PI / 2;
      mainStreetEW.position.y = 0.01;
      scene.add(mainStreetEW);

      // Crosswalk
      const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      for (let i = -5; i <= 5; i++) {
        const stripe = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 8), stripeMat);
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(i * 2, 0.02, 0);
        scene.add(stripe);
      }

      // Load Kenney City buildings
      // Northwest block - Offices
      loadBuilding('building-skyscraper-a', -50, -50, 10);
      loadBuilding('building-skyscraper-b', -35, -55, 10, Math.PI / 2);
      loadBuilding('building-a', -55, -35, 8);

      // Northeast block - Shopping district
      loadBuilding('building-skyscraper-c', 50, -50, 10);
      loadBuilding('building-b', 35, -55, 8);
      loadBuilding('building-c', 55, -35, 8, Math.PI);

      // Southwest block - Residential
      loadBuilding('building-d', -50, 50, 8);
      loadBuilding('building-e', -35, 55, 8);
      loadBuilding('building-f', -55, 35, 8, Math.PI / 2);

      // Southeast block - Mixed use
      loadBuilding('building-skyscraper-d', 50, 50, 10);
      loadBuilding('building-g', 35, 55, 8, Math.PI);
      loadBuilding('building-h', 55, 35, 8);

      // Center area - Shops and cafes
      loadBuilding('building-i', -30, -25, 6);
      loadBuilding('building-j', 30, -25, 6);

      // More buildings for density
      loadBuilding('building-k', -70, 0, 8);
      loadBuilding('building-l', 70, 0, 8);
      loadBuilding('building-m', 0, -70, 8);
      loadBuilding('building-n', 0, 70, 8);

      // Background skyscrapers
      loadBuilding('building-skyscraper-e', -80, -80, 12);
      loadBuilding('building-skyscraper-a', 80, -80, 12, Math.PI);
      loadBuilding('building-skyscraper-b', -80, 80, 12, Math.PI / 2);
      loadBuilding('building-skyscraper-c', 80, 80, 12, -Math.PI / 2);

      // Low detail buildings for far background
      loadBuilding('low-detail-building-a', -100, -40, 15);
      loadBuilding('low-detail-building-b', 100, -40, 15);
      loadBuilding('low-detail-building-c', -100, 40, 15);
      loadBuilding('low-detail-building-d', 100, 40, 15);

      // Park area
      const parkGround = new THREE.Mesh(
        new THREE.CircleGeometry(25, 32),
        new THREE.MeshStandardMaterial({ color: 0x90ee90 })
      );
      parkGround.rotation.x = -Math.PI / 2;
      parkGround.position.set(0, 0.02, 45);
      scene.add(parkGround);

      // Street lamps
      for (let x = -80; x <= 80; x += 25) {
        [12, -12].forEach(z => {
          const lamp = createStreetLamp();
          lamp.position.set(x, 0, z);
          scene.add(lamp);
        });
      }

      // Add Smol characters
      const startPoints = ['center', 'cafe', 'shop', 'park', 'station', 'school', 'ne', 'sw', 'nw', 'se', 'north'];
      characterModels.forEach((config, i) => {
        const start = startPoints[i % startPoints.length];
        loadCharacter(config, start);
      });

      // If no buildings loaded, hide loading immediately
      if (totalToLoad === 0) {
        document.getElementById('loading').style.display = 'none';
      }
    }

    function createStreetLamp() {
      const group = new THREE.Group();
      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 7, 8),
        new THREE.MeshStandardMaterial({ color: 0x2f2f2f })
      );
      pole.position.y = 3.5;
      group.add(pole);

      const lamp = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xfffacd })
      );
      lamp.position.y = 7.2;
      group.add(lamp);

      return group;
    }

    buildCity();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      for (const char of characters) char.update(delta);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // UI Code
    const wsStatus = document.getElementById('ws-status');
    const agentsList = document.getElementById('agents-list');
    const tasksList = document.getElementById('tasks-list');
    const taskCount = document.getElementById('task-count');
    const messagesList = document.getElementById('messages-list');
    const taskInput = document.getElementById('task-input');
    const submitTask = document.getElementById('submit-task');
    const charCount = document.getElementById('char-count');
    const prioritySelect = document.getElementById('priority-select');
    const submitText = document.getElementById('submit-text');
    const serverDot = document.getElementById('server-dot');
    const serverStatusText = document.getElementById('server-status-text');

    let ws = null, serverOnline = false;

    taskInput.addEventListener('input', () => { charCount.textContent = taskInput.value.length; });

    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
      ws.onopen = () => { wsStatus.textContent = 'Online'; wsStatus.className = 'status connected'; submitTask.disabled = false; };
      ws.onclose = () => { wsStatus.textContent = 'Offline'; wsStatus.className = 'status disconnected'; submitTask.disabled = true; setTimeout(connectWebSocket, 3000); };
      ws.onerror = () => {};
      ws.onmessage = (e) => { try { const m = JSON.parse(e.data); if (m.type === 'state_update') updateUI(m.data); } catch {} };
    }

    function updateUI(data) {
      if (data.agents?.length > 0) {
        agentsList.innerHTML = data.agents.map(a => `<div class="agent-card"><div class="agent-avatar">${a.name.charAt(0)}</div><div class="agent-info"><div class="agent-name">${a.name}</div><div class="agent-role">${a.type}</div></div><div class="agent-status ${a.status}">${a.status}</div></div>`).join('');
      }
      const active = (data.tasks || []).filter(t => t.status !== 'completed').slice(0, 5);
      taskCount.textContent = active.length;
      if (active.length > 0) tasksList.innerHTML = active.map(t => `<div class="task-item"><div class="task-title">${t.title}</div><div class="task-meta">Priority: ${t.priority}</div></div>`).join('');
      if (data.messages?.length > 0) messagesList.innerHTML = data.messages.slice(0, 10).map(m => `<div class="message-item"><span class="message-agent">${m.agent_name || 'Agent'}</span>: <span class="message-type ${m.type}">${m.type}</span>${m.content}</div>`).join('');
    }

    async function checkServerHealth() {
      try {
        const res = await fetch('/api/health');
        if (res.ok) { const d = await res.json(); serverOnline = true; serverDot.classList.add('online'); serverStatusText.textContent = d.dbAvailable ? 'Server online!' : 'Server online'; submitTask.disabled = !d.dbAvailable; }
      } catch { serverOnline = false; serverDot.classList.remove('online'); serverStatusText.textContent = 'Server offline'; submitTask.disabled = true; }
    }

    checkServerHealth();
    setInterval(checkServerHealth, 10000);

    submitTask.addEventListener('click', async () => {
      const title = taskInput.value.trim();
      if (!title || !serverOnline) return;
      submitTask.disabled = true; submitText.textContent = 'Sending...';
      try {
        const res = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ title, priority: parseInt(prioritySelect.value) }) });
        if (res.ok) { taskInput.value = ''; charCount.textContent = '0'; submitTask.classList.add('success'); submitText.textContent = 'Sent!'; setTimeout(() => { submitTask.classList.remove('success'); submitText.textContent = 'Send Task'; submitTask.disabled = false; }, 2000); }
      } catch { submitText.textContent = 'Failed'; setTimeout(() => { submitText.textContent = 'Send Task'; submitTask.disabled = false; }, 2000); }
    });

    taskInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey && !submitTask.disabled) { e.preventDefault(); submitTask.click(); } });

    connectWebSocket();
  </script>
</body>
</html>
